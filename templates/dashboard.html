<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Bot Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        /* General Styles */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .navbar {
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .card {
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn-outline-purple {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
        }

        .btn-outline-purple:hover {
            opacity: 0.8;
            color: white;
        }

        /* Console Log Styles */
        #consoleLog {
            background-color: #1e1e1e;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 15px;
            height: 400px;
            overflow-y: auto;
            line-height: 1.4;
        }

        /* Enhanced Log Entry Styles */
        .log-entry {
            margin-bottom: 8px;
            padding: 8px 12px;
            border-radius: 4px;
            border-left: 3px solid transparent;
            background-color: rgba(255, 255, 255, 0.02);
            transition: all 0.2s ease;
        }

        .log-entry:hover {
            background-color: rgba(255, 255, 255, 0.05);
            transform: translateX(2px);
        }

        .log-entry.log-error {
            border-left-color: #ff4757;
            background-color: rgba(255, 71, 87, 0.1);
            color: #ff6b7a;
        }

        .log-entry.log-warning {
            border-left-color: #ffa502;
            background-color: rgba(255, 165, 2, 0.1);
            color: #ffb84d;
        }

        .log-entry.log-success {
            border-left-color: #2ed573;
            background-color: rgba(46, 213, 115, 0.1);
            color: #7bed9f;
        }

        .log-entry.log-info {
            border-left-color: #5352ed;
            background-color: rgba(83, 82, 237, 0.1);
            color: #a4b0f5;
        }

        .log-entry.log-trade {
            border-left-color: #ff9ff3;
            background-color: rgba(255, 159, 243, 0.1);
            color: #ff9ff3;
        }

        .log-entry.log-strategy {
            border-left-color: #3742fa;
            background-color: rgba(55, 66, 250, 0.1);
            color: #7d8bff;
        }

        .log-entry.log-default {
            border-left-color: #747d8c;
            color: #a4b0be;
        }

        .log-header {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
            font-size: 11px;
            opacity: 0.8;
        }

        .log-timestamp {
            color: #6c5ce7;
            margin-right: 8px;
            font-weight: bold;
            font-size: 10px;
        }

        .log-type-icon {
            margin-right: 6px;
            font-size: 12px;
        }

        .log-message {
            font-size: 12px;
            line-height: 1.3;
            word-wrap: break-word;
            padding-left: 2px;
        }

        /* Category Grouping */
        .log-category-header {
            background: linear-gradient(90deg, #2c2c2c, #1e1e1e);
            color: #00d2d3;
            padding: 6px 12px;
            margin: 12px -15px 8px -15px;
            font-weight: bold;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-top: 1px solid #333;
            border-bottom: 1px solid #333;
        }

        .log-separator {
            height: 1px;
            background: linear-gradient(90deg, transparent, #333, transparent);
            margin: 15px 0;
            opacity: 0.5;
        }

        /* Scrollbar Styling */
        #consoleLog::-webkit-scrollbar {
            width: 8px;
        }

        #consoleLog::-webkit-scrollbar-track {
            background: #2c2c2c;
            border-radius: 4px;
        }

        #consoleLog::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        #consoleLog::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        /* Strategy Block Styles */
        .log-strategy-block {
            border: 1px solid #444;
            border-radius: 8px;
            margin: 12px 0;
            padding: 12px;
            background: rgba(255, 255, 255, 0.02);
        }

        .strategy-block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid #444;
        }

        .strategy-name {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .strategy-block-content {
            font-size: 11px;
            line-height: 1.4;
        }

        .strategy-data-row {
            margin: 3px 0;
            color: #a4b0be;
        }

        .strategy-data-row span {
            font-weight: bold;
        }

        /* Active Position Block Styles */
        .log-position-block {
            border-radius: 12px;
            margin: 15px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .position-block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 2px solid currentColor;
        }

        .position-title {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .position-block-content {
            font-size: 12px;
            line-height: 1.5;
        }

        .position-data-row {
            margin: 5px 0;
            color: #ffffff;
            display: flex;
            justify-content: space-between;
        }

        .position-data-row span {
            font-weight: bold;
        }

        /* Positions Table Styles */
        #positionsTable .table {
            margin-bottom: 0;
        }

        .table-responsive {
            overflow-x: auto;
        }

        /* Strategy Configuration Styles */
        .strategy-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .strategy-table th, .strategy-table td {
            padding: 8px;
            border: 1px solid #ddd;
            text-align: left;
        }

        .strategy-table th {
            background-color: #f2f2f2;
        }

        /* Chart Container Styles */
        .chart-container {
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Environment Switch Styles */
        .environment-section {
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Strategy Card Styles */
        .border-left-primary {
            border-left: 4px solid #4e73df !important;
        }

        .bg-gradient-primary {
            background: linear-gradient(135deg, #4e73df 0%, #224abe 100%);
        }

        .strategy-card {
            transition: transform 0.2s ease-in-out;
        }

        .strategy-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .strategy-params-preview {
            background: #f8f9fc;
            border: 1px solid #e3e6f0;
            border-radius: 5px;
            padding: 8px;
            margin-top: 10px;
        }

        /* Environment Controls */
        .environment-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .environment-info {
            text-align: center;
        }

        .environment-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
        }

        .environment-badge.testnet {
            background: #e3f2fd;
            color: #1565c0;
            border: 2px solid #1565c0;
        }

        .environment-badge.mainnet {
            background: #ffebee;
            color: #c62828;
            border: 2px solid #c62828;
        }

        /* Toggle Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 200px;
            height: 50px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1565c0;
            transition: .4s;
            border-radius: 25px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            font-weight: bold;
            font-size: 12px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 40px;
            width: 90px;
            left: 5px;
            bottom: 5px;
            background: white;
            transition: .4s;
            border-radius: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        input:checked + .slider {
            background: #c62828;
        }

        input:checked + .slider:before {
            transform: translateX(90px);
        }

        .slider-text {
            z-index: 1;
            color: white;
            position: relative;
        }

        .slider-text.testnet {
            margin-left: 10px;
        }

        .slider-text.mainnet {
            margin-right: 10px;
        }

        input:not(:checked) + .slider .testnet {
            color: #1565c0;
        }

        input:checked + .slider .mainnet {
            color: #c62828;
        }

        .environment-warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            width: 100%;
        }
    </style>
</head>
<body class="bg-light">
    <nav class="navbar navbar-dark bg-dark">
        <div class="container-fluid">
            <span class="navbar-brand mb-0 h1">
                <i class="fas fa-robot"></i> Trading Bot Dashboard
            </span>
            <div class="d-flex">
                <span class="badge bg-secondary me-2" id="statusBadge">
                    LOADING...
                </span>
                <button id="botToggle" class="btn btn-secondary btn-sm">
                    Loading...
                </button>
            </div>
        </div>
    </nav>

    <div class="container-fluid mt-4">
        <div class="row">
            <!-- Bot Status Card -->
            <div class="col-md-3">
                <div class="card">
                    <div class="card-header bg-primary text-white">
                        <h5><i class="fas fa-info-circle"></i> Bot Status</h5>
                    </div>
                    <div class="card-body">
                        <p><strong>Status:</strong> <span id="botStatus" class="badge bg-secondary">Loading...</span></p>
                        <p><strong>Balance:</strong> $<span id="balance">Loading...</span> USDT</p>
                        <p><strong>Active Positions:</strong> <span id="activePositions">0</span></p>
                        <p><strong>Active Strategies:</strong> <span id="activeStrategies">0</span></p>
                        <p><strong>Environment:</strong> <span id="environment" class="badge bg-info">MAINNET</span></p>
                        <button class="btn btn-info btn-sm" onclick="refreshData()">
                            <i class="fas fa-sync"></i> Refresh
                        </button>
                    </div>
                </div>
            </div>

            <!-- Quick Actions -->
            <div class="col-md-9">
                <div class="card">
                    <div class="card-header bg-warning text-dark">
                        <h5><i class="fas fa-bolt"></i> Quick Actions</h5>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-2">
                                <button class="btn btn-outline-primary w-100 mb-2" onclick="showStrategiesInfo()">
                                    <i class="fas fa-cog"></i><br>View Strategies
                                </button>
                            </div>
                            <div class="col-md-2">
                                <button class="btn btn-outline-success w-100 mb-2" onclick="refreshData()">
                                    <i class="fas fa-chart-line"></i><br>Refresh Data
                                </button>
                            </div>
                            <div class="col-md-2">
                                <button class="btn btn-outline-info w-100 mb-2" onclick="clearConsoleLog()">
                                    <i class="fas fa-trash"></i><br>Clear Console
                                </button>
                            </div>
                            <div class="col-md-2">
                                <button class="btn btn-outline-dark w-100 mb-2" onclick="showConsoleInfo()">
                                    <i class="fas fa-terminal"></i><br>Console Info
                                </button>
                            </div>
                            <div class="col-md-2">
                                <button class="btn btn-outline-warning w-100 mb-2" onclick="editStrategy()">
                                    <i class="fas fa-edit"></i><br>Edit Strategy
                                </button>
                            </div>
                            <div class="col-md-2">
                                <button class="btn btn-outline-secondary w-100 mb-2" onclick="showAnomalies()">
                                    <i class="fas fa-exclamation-triangle"></i><br>Anomalies
                                </button>
                            </div>
                            <div class="col-md-2">
                                <a href="/ml_reports" target="_blank" class="btn btn-outline-purple w-100 mb-2" style="text-decoration: none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                    <i class="fas fa-brain"></i><br>ML Reports
                                </a>
                            </div>
                            <div class="col-md-2">
                                <a href="/trades_database" target="_blank" class="btn btn-outline-info w-100 mb-2" style="text-decoration: none;">
                                    <i class="fas fa-database"></i><br>Trades Database
                                </a>
                            </div>
                        </div>
                    </div>

                    <!-- Trading Mode Info -->
                    <div class="environment-section">
                        <h3>üåê Trading Environment</h3>
                        <div class="environment-controls">
                            <div style="text-align: center; padding: 15px; background: #c8e6c9; border: 1px solid #4caf50; border-radius: 5px; color: #2e7d32;">
                                <strong>üöÄ MAINNET MODE ACTIVE</strong><br>
                                <small>Trading with real funds</small>
                            </div>


                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Active Positions and Console Log -->
        <div class="row mt-4">
            <!-- Active Positions -->
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header bg-success text-white">
                        <h5><i class="fas fa-coins"></i> Active Positions</h5>
                    </div>
                    <div class="card-body">
                        <div id="positionsTable">
                            <div class="table-responsive">
                                <table class="table table-striped">
                                    <thead>
                                        <tr>
                                            <th>Strategy</th>
                                            <th>Symbol</th>
                                            <th>Side</th>
                                            <th>Entry Price</th>
                                            <th>Margin (USDT)</th>
                                            <th>Current Price</th>
                                            <th>PnL (USDT)</th>
                                            <th>PnL (%)</th>
                                            <th>Current RSI</th>
                                        </tr>
                                    </thead>
                                    <tbody id="positionsTableBody">
                                        <tr>
                                            <td colspan="9" class="text-muted text-center">Loading positions...</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Live Console Log -->
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header bg-dark text-white">
                        <h5><i class="fas fa-terminal"></i> Live Console Log</h5>
                        <div class="float-end">
                            <button class="btn btn-sm btn-outline-light" onclick="clearConsoleLog()">
                                <i class="fas fa-trash"></i> Clear
                            </button>
                            <button class="btn btn-sm btn-outline-light" onclick="toggleAutoScroll()" id="autoScrollBtn">
                                <i class="fas fa-arrows-alt-v"></i> Auto-scroll: ON
                            </button>
                        </div>
                    </div>
                    <div class="card-body p-0">
                        <div id="consoleLog" style="height: 400px; overflow-y: auto; background-color: #1e1e1e; color: #ffffff; font-family: 'Courier New', monospace; font-size: 12px; padding: 10px;">
                            <div class="text-muted">Waiting for console output...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Strategy Configuration Section -->
        <div class="row mt-4">
            <div class="col-12">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h3><i class="fas fa-cogs"></i> Strategy Configuration</h3>
                    <button class="btn btn-primary" onclick="addNewStrategy()">
                        <i class="fas fa-plus"></i> Add New Strategy
                    </button>
                </div>

                <!-- Individual Strategy Cards -->
                {% for strategy_name, config in strategies.items() %}
                <div class="col-md-6 mb-3">
                    <div class="card border-left-primary">
                        <div class="card-header bg-gradient-primary text-white">
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <h5 class="mb-0">
                                        <i class="fas fa-chart-line"></i> 
                                        {{ strategy_name.replace('_', ' ').title() }}
                                    </h5>
                                    <small class="text-light">
                                        {% if 'rsi' in strategy_name.lower() %}
                                            RSI-Based Strategy
                                        {% elif 'macd' in strategy_name.lower() %}
                                            MACD Divergence Strategy
                                        {% else %}
                                            Custom Strategy
                                        {% endif %}
                                    </small>
                                </div>
                                {% set is_disabled = config.get('assessment_interval', 60) == 0 or config.get('enabled', True) == False %}
                                {% if is_disabled %}
                                <span class="badge bg-secondary">
                                    <i class="fas fa-pause"></i> Disabled
                                </span>
                                {% else %}
                                <span class="badge bg-success">
                                    <i class="fas fa-play"></i> Active
                                </span>
                                {% endif %}
                            </div>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="mb-2">
                                        <strong>Symbol:</strong>
                                        <span class="badge bg-primary ms-1">{{ config.symbol }}</span>
                                    </div>
                                    <div class="mb-2">
                                        <strong>Margin:</strong>
                                        <span class="text-success">${{ "%.2f"|format(config.margin) }} USDT</span>
                                    </div>
                                    <div class="mb-2">
                                        <strong>Leverage:</strong>
                                        <span class="badge bg-info">{{ config.leverage }}x</span>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="mb-2">
                                        <strong>Timeframe:</strong>
                                        <span class="badge bg-secondary">{{ config.timeframe }}</span>
                                    </div>
                                    <div class="mb-2">
                                        <strong>Max Loss:</strong>
                                        <span class="text-warning">{{ config.get('max_loss_pct', 10) }}%</span>
                                    </div>
                                    <div class="mb-2">
                                        <strong>Assessment:</strong>
                                        <span class="text-info">{{ config.get('assessment_interval', 60) }}s</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Strategy-Specific Parameters Preview -->
                            {% if 'rsi' in strategy_name.lower() %}
                            <div class="mt-2 p-2 bg-light rounded">
                                <small class="text-muted">
                                    <strong>RSI Levels:</strong> 
                                    Long Entry: {{ config.get('rsi_long_entry', 30) }} | 
                                    Long Exit: {{ config.get('rsi_long_exit', 70) }} |
                                    Short Entry: {{ config.get('rsi_short_entry', 70) }} | 
                                    Short Exit: {{ config.get('rsi_short_exit', 30) }}
                                </small>
                            </div>
                            {% elif 'macd' in strategy_name.lower() %}
                            <div class="mt-2 p-2 bg-light rounded">
                                <small class="text-muted">
                                    <strong>MACD Settings:</strong> 
                                    Fast: {{ config.get('macd_fast', 12) }} | 
                                    Slow: {{ config.get('macd_slow', 26) }} | 
                                    Signal: {{ config.get('macd_signal', 9) }} |
                                    Min Histogram: {{ config.get('min_histogram_threshold', 0.0001) }}
                                </small>
                            </div>
                            {% endif %}
                        </div>
                        <div class="card-footer text-center">
                            <button class="btn btn-primary btn-sm me-2" onclick="editStrategyConfig('{{ strategy_name }}')">
                                <i class="fas fa-edit"></i> Configure Strategy
                            </button>
                            <button class="btn btn-outline-warning btn-sm me-2" onclick="viewStrategyStats('{{ strategy_name }}')">
                                <i class="fas fa-chart-bar"></i> View Stats
                            </button>
                            {% set is_disabled = config.get('assessment_interval', 60) == 0 or config.get('enabled', True) == False %}
                            {% if is_disabled %}
                            <button class="btn btn-outline-success btn-sm strategy-toggle-btn" data-strategy="{{ strategy_name }}" data-state="disabled" onclick="enableStrategy('{{ strategy_name }}')">
                                <i class="fas fa-play"></i> Enable
                            </button>
                            {% else %}
                            <button class="btn btn-outline-danger btn-sm strategy-toggle-btn" data-strategy="{{ strategy_name }}" data-state="enabled" onclick="disableStrategy('{{ strategy_name }}')">
                                <i class="fas fa-pause"></i> Disable
                            </button>
                            {% endif %}
                        </div>
                    </div>
                </div>
                {% endfor %}
            </div>
        </div>
    </div>

    <!-- Add New Strategy Modal -->
    <div class="modal fade" id="addStrategyModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Add New Strategy</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-info">
                        <i class="fas fa-info-circle"></i>
                        Create a new trading strategy. All strategy types are supported: RSI, MACD, and any custom strategy.
                    </div>

                    <form id="addStrategyForm">
                        <div class="row">
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="newStrategyName" class="form-label">Strategy Name</label>
                                    <input type="text" class="form-control" id="newStrategyName" 
                                           placeholder="e.g., RSI_CRYPTO, MACD_FUTURES" required>
                                    <div class="form-text">Include "rsi", "macd", or any custom name</div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="newStrategyType" class="form-label">Strategy Type</label>
                                    <select class="form-control" id="newStrategyType">
                                        <option value="auto">Auto-detect from name</option>
                                        <option value="rsi">RSI Strategy</option>
                                        <option value="macd">MACD Strategy</option>
                                        <option value="universal">Custom/Universal</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div class="row">
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="newStrategySymbol" class="form-label">Trading Symbol</label>
                                    <input type="text" class="form-control" id="newStrategySymbol" 
                                           placeholder="BTCUSDT" required>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="newStrategyTimeframe" class="form-label">Timeframe</label>
                                    <select class="form-control" id="newStrategyTimeframe">
                                        <option value="1m">1 minute</option>
                                        <option value="3m">3 minutes</option>
                                        <option value="5m">5 minutes</option>
                                        <option value="15m" selected>15 minutes</option>
                                        <option value="30m">30 minutes</option>
                                        <option value="1h">1 hour</option>
                                        <option value="4h">4 hours</option>
                                        <option value="1d">1 day</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div class="row">
                            <div class="col-md-4">
                                <div class="mb-3">
                                    <label for="newStrategyMargin" class="form-label">Margin (USDT)</label>
                                    <input type="number" class="form-control" id="newStrategyMargin" 
                                           value="50" min="0.01" max="10000" step="0.01" required>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="mb-3">
                                    <label for="newStrategyLeverage" class="form-label">Leverage</label>
                                    <input type="number" class="form-control" id="newStrategyLeverage" 
                                           value="5" min="1" max="125" required>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="mb-3">
                                    <label for="newStrategyMaxLoss" class="form-label">Max Loss %</label>
                                    <input type="number" class="form-control" id="newStrategyMaxLoss" 
                                           value="10" min="0.1" max="100" step="0.1" required>
                                </div>
                            </div>
                        </div>

                        <div class="row">
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="newStrategyInterval" class="form-label">Assessment Interval (seconds)</label>
                                    <input type="number" class="form-control" id="newStrategyInterval" 
                                           value="60" min="5" max="3600" required>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="mb-3">
                                    <label for="newStrategyCooldown" class="form-label">Cooldown Period (seconds)</label>
                                    <input type="number" class="form-control" id="newStrategyCooldown" 
                                           value="300" min="30" max="7200" required>
                                </div>
                            </div>
                        </div>

                        <!-- Strategy-specific parameters will be shown based on type -->
                        <div id="strategySpecificParams" class="mt-3">
                            <h6>Strategy-Specific Parameters</h6>
                            <div class="alert alert-secondary">
                                <small>Advanced parameters can be configured after creation via the "Configure Strategy" button.</small>
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" onclick="saveNewStrategy()">Create Strategy</button>
                </div>
            </div>        </div>
    </div>
    <!-- Strategy Edit Modal -->
    <div class="modal fade" id="strategyModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Edit Strategy Configuration</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="strategyForm">
                        <input type="hidden" id="strategyName" />
                        <div class="mb-3">
                            <label for="strategySymbol" class="form-label">Symbol</label>
                            <input type="text" class="form-control" id="strategySymbol" placeholder="e.g., BTCUSDT">
                            <div class="form-text" style="color: black; font-size: 0.825rem;">
                                <strong>Function:</strong> The cryptocurrency pair to trade (e.g., BTCUSDT, ETHUSDT, SOLUSDT)<br>
                                <strong>Recommended:</strong> Use high-volume pairs like BTCUSDT (conservative) or SOLUSDT (aggressive)
                            </div>
                        </div>
                        <div class="mb-3">
                            <label for="strategyMargin" class="form-label">Margin (USDT)</label>
                            <input type="number" class="form-control" id="strategyMargin" step="0.1" min="1">
                            <div class="form-text" style="color: black; font-size: 0.825rem;">
                                <strong>Function:</strong> Amount of USDT to use as margin for each trade position<br>
                                <strong>Recommended:</strong> Start with $10-50 USDT for testing, scale up based on results
                            </div>
                        </div>
                        <div class="mb-3">
                            <label for="strategyLeverage" class="form-label">Leverage</label>
                            <input type="number" class="form-control" id="strategyLeverage" min="1" max="125">
                            <div class="form-text" style="color: black; font-size: 0.825rem;">
                                <strong>Function:</strong> Multiplier for position size - higher leverage = higher profit/loss potential<br>
                                <strong>Recommended:</strong> 3-10x for conservative, 15-25x for aggressive (never exceed 50x)
                            </div>
                        </div>
                         <div class="mb-3">
                            <label for="strategyDecimals" class="form-label">Decimal Precision</label>
                            <input type="number" class="form-control" id="strategyDecimals" min="0" max="8" value="2">
                            <div class="form-text" style="color: black; font-size: 0.825rem;">
                                <strong>Function:</strong> Number of decimal places for price calculations and display<br>
                                <strong>Recommended:</strong> 2 for most pairs, 3 for BTC pairs, 4+ for very low-value coins
                            </div>
                        </div>
                        <div class="mb-3">
                            <label for="strategyTimeframe" class="form-label">Timeframe</label>
                            <select class="form-control" id="strategyTimeframe">
                                <option value="1m">1 minute</option>
                                <option value="5m">5 minutes</option>
                                <option value="15m">15 minutes</option>
                                <option value="1h">1 hour</option>
                                <option value="4h">4 hours</option>
                                <option value="1d">1 day</option>
                            </select>
                            <div class="form-text" style="color: black; font-size: 0.825rem;">
                                <strong>Function:</strong> Chart timeframe for technical analysis and signal generation<br>
                                <strong>Recommended:</strong> 15m for balanced trading, 5m for scalping, 1h+ for swing trading
                            </div>
                        </div>
                        <div class="mb-3">
                            <label for="strategyMaxLoss" class="form-label">Max Loss % (of margin)</label>
                            <input type="number" class="form-control" id="strategyMaxLoss" step="0.1" min="1" max="50" placeholder="e.g., 10">
                            <div class="form-text" style="color: black; font-size: 0.825rem;">
                                <strong>Function:</strong> Maximum loss as percentage of margin before automatic stop-loss triggers<br>
                                <strong>Recommended:</strong> 5-10% for conservative, 10-20% for moderate risk tolerance
                            </div>
                        </div>
                        <div class="mb-3">
                            <label for="assessmentInterval" class="form-label">Market Assessment Interval (seconds)</label>
                            <input type="number" class="form-control" id="assessmentInterval" step="1" min="5" max="300" placeholder="e.g., 60">
                            <div class="form-text" style="color: black; font-size: 0.825rem;">
                                <strong>Function:</strong> How often the bot scans market data for new entry opportunities<br>
                                <strong>Recommended:</strong> 30-60 seconds for active trading, 120+ seconds for conservative approach
                            </div>
                        </div>
                        <div class="mb-3">
                            <label for="cooldownPeriod" class="form-label">Cooldown Period (seconds)</label>
                            <input type="number" class="form-control" id="cooldownPeriod" step="1" min="30" max="3600" placeholder="e.g., 300">
                            <div class="form-text" style="color: black; font-size: 0.825rem;">
                                <strong>Function:</strong> Waiting time after closing a position before allowing new trades on same symbol<br>
                                <strong>Recommended:</strong> 300-600 seconds (5-10 minutes) to avoid overtrading and emotional decisions
                            </div>
                        </div>
						<!-- Partial Take Profit Master Toggle -->
                        <div class="mb-4">
                            <h6 class="text-success mt-3">üéØ Partial Take Profit Configuration</h6>
                            <div class="form-check form-switch mb-3">
                                <input class="form-check-input" type="checkbox" id="partialTpEnabled" onchange="togglePartialTpConfig()">
                                <label class="form-check-label" for="partialTpEnabled">
                                    <strong>Enable Partial Take Profit</strong>
                                </label>
                                <div class="form-text">Enable to configure automatic partial profit taking</div>
                            </div>

                            <!-- Partial TP Configuration Fields (disabled by default) -->
                            <div id="partialTpConfigSection" class="mt-3" style="opacity: 0.5;">
                                <div class="row">
                                    <div class="col-md-6">
                                        <div class="mb-3">
                                            <label for="partialTpPnlThreshold" class="form-label">Partial TP PnL Threshold %</label>
                                            <input type="number" class="form-control" id="partialTpPnlThreshold" step="0.1" min="1" max="1000" placeholder="e.g., 50" disabled oninput="updatePartialTpExample()">
                                            <div class="form-text" style="color: black; font-size: 0.825rem;">
                                                <strong>Function:</strong> When profit reaches this % of margin, partial take-profit triggers<br>
                                                <strong>Recommended:</strong> 30-50% for conservative, 75-100% for letting profits run longer
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="mb-3">
                                            <label for="partialTpPositionPercentage" class="form-label">Partial TP Position Size %</label>
                                            <input type="number" class="form-control" id="partialTpPositionPercentage" step="0.1" min="1" max="99" placeholder="e.g., 50" disabled oninput="updatePartialTpExample()">
                                            <div class="form-text" style="color: black; font-size: 0.825rem;">
                                                <strong>Function:</strong> What percentage of the position to close when partial TP triggers<br>
                                                <strong>Recommended:</strong> 25-50% to secure profits while keeping remainder for further gains
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Example Calculation Display -->
                                <div class="alert alert-info mt-2" id="partialTpExample">
                                    <small>
                                        <strong>Example:</strong> With 50% PnL threshold and 50% position size:<br>
                                        ‚Ä¢ When profit reaches 50% of margin ‚Üí Close 50% of position<br>
                                        ‚Ä¢ Remaining 50% continues until stop loss or manual exit
                                    </small>
                                </div>
                            </div>
                        </div>

                        <!-- RSI Strategy Parameters (shown only for RSI strategies) -->
                        <div id="rsiParameters" style="display: none;">
                            <h6 class="text-primary mt-3">RSI Strategy Parameters</h6>
                            <div class="row">
                                <div class="col-6">
                                    <label for="rsiLongEntry" class="form-label">RSI Long Entry</label>
                                    <input type="number" class="form-control" id="rsiLongEntry" min="10" max="50" placeholder="e.g., 40">
                                    <div class="form-text" style="color: black; font-size: 0.825rem;">
                                        <strong>Function:</strong> RSI level to trigger BUY (long) positions<br>
                                        <strong>Recommended:</strong> 25-35 for oversold entries, 40-45 for moderate entries
                                    </div>
                                </div>
                                <div class="col-6">
                                    <label for="rsiLongExit" class="form-label">RSI Long Exit</label>
                                    <input type="number" class="form-control" id="rsiLongExit" min="50" max="90" placeholder="e.g., 70">
                                    <div class="form-text" style="color: black; font-size: 0.825rem;">
                                        <strong>Function:</strong> RSI level to close BUY positions (take profit)<br>
                                        <strong>Recommended:</strong> 65-75 for conservative exits, 75-80 for letting profits run
                                    </div>
                                </div>
                            </div>
                            <div class="row mt-2">
                                <div class="col-6">
                                    <label for="rsiShortEntry" class="form-label">RSI Short Entry</label>
                                    <input type="number" class="form-control" id="rsiShortEntry" min="50" max="90" placeholder="e.g., 60">
                                    <div class="form-text" style="color: black; font-size: 0.825rem;">
                                        <strong>Function:</strong> RSI level to trigger SELL (short) positions<br>
                                        <strong>Recommended:</strong> 65-75 for overbought entries, 55-60 for moderate entries
                                    </div>
                                </div>
                                <div class="col-6">
                                    <label for="rsiShortExit" class="form-label">RSI Short Exit</label>
                                    <input type="number" class="form-control" id="rsiShortExit" min="10" max="50" placeholder="e.g., 30">
                                    <div class="form-text" style="color: black; font-size: 0.825rem;">
                                        <strong>Function:</strong> RSI level to close SELL positions (take profit)<br>
                                        <strong>Recommended:</strong> 20-35 for conservative exits, 15-25 for maximum profit extraction
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- MACD Strategy Parameters (shown only for MACD strategies) -->
                        <!-- MACD Strategy Parameters (shown only for MACD strategies) -->
                        <div id="macdParameters" style="display: none;">
                            <h6 class="text-primary mt-3">MACD Strategy Parameters</h6>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="macdFast" class="form-label">MACD Fast Length</label>
                                        <input type="number" class="form-control" id="macdFast" min="2" max="30" placeholder="e.g., 12">
                                        <div class="form-text" style="color: black; font-size: 0.825rem;">
                                            <strong>Function:</strong> Fast EMA period for MACD calculation (shorter = more sensitive)<br>
                                            <strong>Recommended:</strong> 12 for standard, 8-10 for faster signals, 15-20 for smoother signals
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="macdSlow" class="form-label">MACD Slow Length</label>
                                        <input type="number" class="form-control" id="macdSlow" min="12" max="50" placeholder="e.g., 26">
                                        <div class="form-text" style="color: black; font-size: 0.825rem;">
                                            <strong>Function:</strong> Slow EMA period for MACD calculation (longer = trend filter)<br>
                                            <strong>Recommended:</strong> 26 for standard, 21-24 for faster, 30-35 for stronger trend filter
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="macdSignal" class="form-label">MACD Signal Length</label>
                                        <input type="number" class="form-control" id="macdSignal" min="2" max="20" placeholder="e.g., 9">
                                        <div class="form-text" style="color: black; font-size: 0.825rem;">
                                            <strong>Function:</strong> Signal line EMA period (smooths MACD line for crossover signals)<br>
                                            <strong>Recommended:</strong> 9 for standard, 7-8 for faster signals, 12-15 for smoother signals
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="minHistogramThreshold" class="form-label">Min Histogram Threshold</label>
                                        <input type="number" class="form-control" id="minHistogramThreshold" step="0.00001" placeholder="e.g., 0.0001">
                                        <div class="form-text" style="color: black; font-size: 0.825rem;">
                                            <strong>Function:</strong> Minimum histogram value required to validate MACD signals<br>
                                            <strong>Recommended:</strong> 0.0001 for BTC, 0.001 for ETH, 0.01 for altcoins (adjust per symbol)
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="macdEntryThreshold" class="form-label">Entry Threshold</label>
                                        <input type="number" class="form-control" id="macdEntryThreshold" step="0.01" placeholder="e.g., 0.05">
                                        <div class="form-text" style="color: black; font-size: 0.825rem;">
                                            <strong>Function:</strong> Minimum MACD crossover strength required to enter positions<br>
                                            <strong>Recommended:</strong> 0.03-0.07 for conservative, 0.01-0.03 for aggressive entry signals
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="macdExitThreshold" class="form-label">Exit Threshold</label>
                                        <input type="number" class="form-control" id="macdExitThreshold" step="0.01" placeholder="e.g., 0.02">
                                        <div class="form-text" style="color: black; font-size: 0.825rem;">
                                            <strong>Function:</strong> MACD crossover strength needed to exit positions (take profit/stop loss)<br>
                                            <strong>Recommended:</strong> 0.02-0.04 for conservative exits, 0.005-0.02 for quick exits
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="divergenceStrengthMin" class="form-label">Divergence Strength Min</label>
                                        <input type="number" class="form-control" id="divergenceStrengthMin" step="0.1" min="0.1" max="1.0" placeholder="e.g., 0.6">
                                        <div class="form-text" style="color: black; font-size: 0.825rem;">
                                            <strong>Function:</strong> Minimum strength of price/MACD divergence to trigger signals<br>
                                            <strong>Recommended:</strong> 0.4-0.6 for balanced, 0.7-0.9 for high-confidence signals only
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="histogramDivergenceLookback" class="form-label">Histogram Divergence Lookback</label>
                                        <input type="number" class="form-control" id="histogramDivergenceLookback" min="5" max="50" placeholder="e.g., 10">
                                        <div class="form-text" style="color: black; font-size: 0.825rem;">
                                            <strong>Function:</strong> How many candles back to analyze histogram divergence patterns<br>
                                            <strong>Recommended:</strong> 8-12 for short-term, 15-25 for medium-term divergence detection
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="priceDivergenceLookback" class="form-label">Price Divergence Lookback</label>
                                        <input type="number" class="form-control" id="priceDivergenceLookback" min="5" max="50" placeholder="e.g., 10">
                                        <div class="form-text" style="color: black; font-size: 0.825rem;">
                                            <strong>Function:</strong> How many candles back to analyze price divergence patterns<br>
                                            <strong>Recommended:</strong> 8-12 for short-term, 15-25 for identifying stronger divergences
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="mb-3">
                                        <label for="confirmationCandles" class="form-label">Confirmation Candles</label>
                                        <input type="number" class="form-control" id="confirmationCandles" min="1" max="5" placeholder="e.g., 2">
                                        <div class="form-text" style="color: black; font-size: 0.825rem;">
                                            <strong>Function:</strong> Number of consecutive candles needed to confirm momentum direction<br>
                                            <strong>Recommended:</strong> 2-3 for balance of speed vs accuracy, 1 for fast entries, 4-5 for high confidence
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" onclick="saveStrategyConfig()">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables for auto-scroll
        let autoScroll = true;
        let consoleLogBuffer = [];

        // Add autoRefresh variable
        let autoRefresh = true;

        // Bot control functions
        document.getElementById('botToggle').addEventListener('click', function() {
            const isRunning = this.textContent.includes('Stop');
            const endpoint = isRunning ? '/api/bot/stop' : '/api/bot/start';

            fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    location.reload();
                } else {
                    alert('Error: ' + data.message);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Connection error');
            });
        });

        // Refresh data
        function refreshData() {
            updateBotStatus();
            updateBalance();
            updatePositions();
            // Only update console if auto-refresh is enabled
            if (autoRefresh) {
                updateConsoleLog();
            }
        }

        // üîß INTELLIGENT API POLLING SYSTEM - Prevents excessive requests
        const apiCache = {
            botStatus: { data: null, timestamp: 0, ttl: 8000, consecutiveHits: 0 },     // 8 second cache, track stability
            balance: { data: null, timestamp: 0, ttl: 30000, consecutiveHits: 0 },      // 30 second cache
            positions: { data: null, timestamp: 0, ttl: 12000, consecutiveHits: 0 },    // 12 second cache
            consoleLog: { data: null, timestamp: 0, ttl: 5000, consecutiveHits: 0 }     // 5 second cache for console
        };

        const requestThrottle = {
            botStatus: { lastRequest: 0, minInterval: 8000, maxInterval: 20000, currentInterval: 8000 },
            balance: { lastRequest: 0, minInterval: 30000, maxInterval: 60000, currentInterval: 30000 },
            positions: { lastRequest: 0, minInterval: 12000, maxInterval: 25000, currentInterval: 12000 },
            consoleLog: { lastRequest: 0, minInterval: 5000, maxInterval: 15000, currentInterval: 5000 }
        };

        let activeRequests = new Set(); // Track active requests to prevent duplicates
        let connectionState = 'healthy'; // Track connection health: 'healthy', 'degraded', 'poor'
        let inactivityCount = 0; // Track consecutive inactive periods

        function getCachedData(cacheKey) {
            const cache = apiCache[cacheKey];
            const now = Date.now();

            if (cache.data && (now - cache.timestamp) < cache.ttl) {
                // Track cache hits for adaptive behavior
                cache.consecutiveHits = (cache.consecutiveHits || 0) + 1;

                // If data is stable (many cache hits), extend TTL to reduce polling
                if (cache.consecutiveHits > 3) {
                    cache.ttl = Math.min(cache.ttl * 1.2, 30000); // Max 30 seconds
                }

                return cache.data;
            }

            // Reset consecutive hits when cache expires
            cache.consecutiveHits = 0;
            return null;
        }

        function setCachedData(cacheKey, data) {
            const cache = apiCache[cacheKey];
            const previousData = cache.data;

            cache.data = data;
            cache.timestamp = Date.now();

            // Check if data has changed to adjust adaptive behavior
            const dataChanged = JSON.stringify(previousData) !== JSON.stringify(data);

            if (dataChanged) {
                // Data changed - reset to faster polling
                cache.consecutiveHits = 0;
                cache.ttl = Math.max(cache.ttl * 0.8, requestThrottle[cacheKey]?.minInterval || 5000);
                inactivityCount = 0; // Reset global inactivity
            } else {
                // Data stable - can slow down polling
                inactivityCount++;
            }
        }

        function canMakeRequest(requestKey) {
            const throttle = requestThrottle[requestKey];
            const now = Date.now();

            // Adaptive interval based on activity and connection state
            const adaptiveInterval = calculateAdaptiveInterval(requestKey);

            if ((now - throttle.lastRequest) < adaptiveInterval) {
                return false;
            }

            if (activeRequests.has(requestKey)) {
                return false; // Request already in progress
            }

            // Check global rate limiting to prevent API flooding
            if (activeRequests.size >= 2) {
                return false; // Maximum 2 concurrent requests
            }

            return true;
        }

        function calculateAdaptiveInterval(requestKey) {
            const throttle = requestThrottle[requestKey];
            let interval = throttle.currentInterval;

            // Adjust based on connection state
            switch (connectionState) {
                case 'degraded':
                    interval *= 1.5;
                    break;
                case 'poor':
                    interval *= 2;
                    break;
                default: // healthy
                    // Adjust based on inactivity
                    if (inactivityCount > 5) {
                        interval = Math.min(interval * 1.3, throttle.maxInterval);
                    } else if (inactivityCount < 2) {
                        interval = Math.max(interval * 0.9, throttle.minInterval);
                    }
            }

            throttle.currentInterval = Math.max(Math.min(interval, throttle.maxInterval), throttle.minInterval);
            return throttle.currentInterval;
        }

        function markRequestStart(requestKey) {
            requestThrottle[requestKey].lastRequest = Date.now();
            activeRequests.add(requestKey);
        }

        function markRequestEnd(requestKey, success = true) {
            activeRequests.delete(requestKey);

            // Update connection state based on request success
            if (success) {
                if (connectionState === 'poor') connectionState = 'degraded';
                else if (connectionState === 'degraded') connectionState = 'healthy';
            } else {
                if (connectionState === 'healthy') connectionState = 'degraded';
                else if (connectionState === 'degraded') connectionState = 'poor';
            }
        }

        function shouldUpdate(cacheKey) {
            // Check cache first
            const cachedData = getCachedData(cacheKey);
            if (cachedData) {
                return false; // Use cached data, don't make new request
            }

            // Check if we can make a new request
            return canMakeRequest(cacheKey);
        }

        async function cachedApiRequest(url, cacheKey) {
            // Check cache first
            const cachedData = getCachedData(cacheKey);
            if (cachedData) {
                return cachedData;
            }

            // Make API request
            const data = await apiRequest(url);

            // Cache the response
            if (data) {
                setCachedData(cacheKey, data);
            }

            return data;
        }

        function recordApiSuccess(cacheKey) {
            // Reset error counters, adjust intervals, etc.
            const throttle = requestThrottle[cacheKey];
            if (throttle) {
                throttle.currentInterval = Math.max(throttle.currentInterval * 0.9, throttle.minInterval);
            }
        }

        function recordApiError(cacheKey) {
            // Increase intervals on error
            const throttle = requestThrottle[cacheKey];
            if (throttle) {
                throttle.currentInterval = Math.min(throttle.currentInterval * 1.5, throttle.maxInterval);
            }
        }

        // Simple bot status update
        function updateBotStatus() {
            apiRequest('/api/bot/status')
                .then(data => {
                    if (data && data.success !== false) {
                        const statusElement = document.getElementById('statusBadge');
                        const botToggle = document.getElementById('botToggle');
                        const botStatus = document.getElementById('botStatus');
                        const activePositions = document.getElementById('activePositions');
                        const activeStrategies = document.getElementById('activeStrategies');
                        const balanceElement = document.getElementById('balance');

                        const isRunning = data.running || data.is_running || false;

                        // Update button
                        if (botToggle) {
                            botToggle.disabled = false;
                            if (isRunning) {
                                botToggle.textContent = 'Stop Bot';
                                botToggle.className = 'btn btn-danger btn-sm';
                            } else {
                                botToggle.textContent = 'Start Bot';
                                botToggle.className = 'btn btn-success btn-sm';
                            }
                        }

                        // Update status
                        if (statusElement) {
                            if (isRunning) {
                                statusElement.textContent = 'RUNNING';
                                statusElement.className = 'badge bg-success me-2';
                            } else {
                                statusElement.textContent = 'STOPPED';
                                statusElement.className = 'badge bg-danger me-2';
                            }
                        }

                        if (botStatus) {
                            if (isRunning) {
                                botStatus.textContent = 'RUNNING';
                                botStatus.className = 'badge bg-success';
                            } else {
                                botStatus.textContent = 'STOPPED';
                                botStatus.className = 'badge bg-danger';
                            }
                        }

                        if (activePositions) {
                            activePositions.textContent = data.active_positions || 0;
                        }

                        if (activeStrategies) {
                            activeStrategies.textContent = data.strategies || 0;
                        }

                        if (balanceElement && data.balance !== undefined) {
                            balanceElement.textContent = data.balance.toFixed(2);
                        }
                    }
                })
                .catch(error => {
                    console.error('Error updating bot status:', error);
                });
        }

         function updateBotStatusErrorUI(errorData) {
            // Enhanced offline status handling with error details
            const statusBadge = document.getElementById('statusBadge');
            const botToggle = document.getElementById('botToggle');
            const botStatus = document.getElementById('botStatus');
            const activePositions = document.getElementById('activePositions');

            // Determine error type and appropriate message
            let statusText = 'CONNECTION ISSUE';
            let buttonText = 'Connection Lost';

            if (errorData && errorData.status) {
                switch (errorData.status) {
                    case 'initializing':
                        statusText = 'INITIALIZING...';
                        buttonText = 'Initializing...';
                        break;
                    case 'html_response':
                        statusText = 'SERVER ERROR';
                        buttonText = 'Server Error';
                        break;
                    case 'json_parse_error':
                        statusText = 'DATA ERROR';
                        buttonText = 'Data Error';
                        break;
                    case 'network_error':
                        statusText = 'NETWORK ERROR';
                        buttonText = 'Network Error';
                        break;
                    default:
                        statusText = 'OFFLINE';
                        buttonText = 'Connection Lost';
                }
            }

            if (statusBadge) {
                statusBadge.textContent = statusText;
                statusBadge.className = 'badge bg-warning me-2';
            }

            if (botToggle) {
                // Only update if it's in an error state already
                if (botToggle.textContent.includes('Loading') || 
                    botToggle.textContent.includes('Error') || 
                    botToggle.textContent.includes('Lost') ||
                    botToggle.textContent.includes('Initializing')) {

                    botToggle.textContent = buttonText;
                    botToggle.className = 'btn btn-warning btn-sm';
                    botToggle.disabled = true;

                    // Auto-retry based on error type
                    const retryDelay = errorData && errorData.status === 'initializing' ? 2000 : 5000;
                    setTimeout(() => {
                        if (botToggle.disabled && botToggle.textContent === buttonText) {
                            updateBotStatus(); // Retry
                        }
                    }, retryDelay);
                }
            }

            if (botStatus) {
                botStatus.textContent = statusText;
                botStatus.className = 'badge bg-warning';
            }

            if (activePositions) {
                activePositions.textContent = '?';
            }
        }
        // Simple balance update
        function updateBalance() {
            apiRequest('/api/balance')
                .then(data => {
                    if (data && data.success !== false) {
                        const balance = document.getElementById('balance');
                        if (balance) {
                            balance.textContent = (data.total_balance || 0).toFixed(2);
                        }
                    }
                })
                .catch(error => {
                    console.error('Error updating balance:', error);
                });
        }

        // Update console log with safe API handling
        function updateConsoleLog() {
            // Check cache first
            const cachedData = getCachedData('consoleLog');
            if (cachedData) {
                updateConsoleLogUI(cachedData);
                return Promise.resolve(cachedData);
            }

            // Check if we can make a new request
            if (!canMakeRequest('consoleLog')) {
                return Promise.resolve(null);
            }

            markRequestStart('consoleLog');

            return safeApiCall('/api/console-log')
                .then(data => {
                    setCachedData('consoleLog', data);
                    updateConsoleLogUI(data);
                    markRequestEnd('consoleLog', true);
                    return data;
                })
                .catch(error => {
                    updateConsoleLogErrorUI();
                    markRequestEnd('consoleLog', false);
                    return getDefaultResponse('/api/console-log');
                });
        }

        function updateConsoleLogUI(data) {            const consoleLog = document.getElementById('consoleLog');
            if (consoleLog && data.success && data.logs) {
                // Process logs with enhanced formatting
                const formattedLogs = formatConsoleLogs(data.logs);
                consoleLog.innerHTML = formattedLogs;
                if (autoScroll) {
                    consoleLog.scrollTop = consoleLog.scrollHeight;
                }
            }
        }

        function formatConsoleLogs(logs) {
            if (!logs || logs.length === 0) {
                return '<div class="log-entry log-info">No logs available</div>';
            }

            let formattedOutput = '';
            let currentStrategyBlock = null;
            let blockBuffer = [];

            logs.forEach(function(log, index) {
                if (!log || typeof log !== 'string') return;

                const cleanLog = log.trim();
                if (!cleanLog) return;

                const logType = detectLogType(cleanLog);
                const timestamp = extractTimestamp(cleanLog);
                const message = extractMessage(cleanLog);
                const strategyInfo = extractStrategyInfo(cleanLog);

                // Check if this is a strategy scanning message
                if (isStrategyScanning(cleanLog)) {
                    // Close previous block if different strategy
                    if (currentStrategyBlock && currentStrategyBlock !== strategyInfo.strategy) {
                        formattedOutput += formatStrategyBlock(currentStrategyBlock, blockBuffer);
                        blockBuffer = [];
                    }

                    currentStrategyBlock = strategyInfo.strategy;
                    blockBuffer.push({
                        type: 'scanning',
                        data: strategyInfo,
                        timestamp: timestamp,
                        message: message
                    });
                } else if (isActivePosition(cleanLog)) {
                    // Close any strategy scanning block
                    if (currentStrategyBlock) {
                        formattedOutput += formatStrategyBlock(currentStrategyBlock, blockBuffer);
                        blockBuffer = [];
                        currentStrategyBlock = null;
                    }

                    // Format active position as special block
                    const positionInfo = extractPositionInfo(cleanLog);
                    formattedOutput += formatActivePositionBlock(positionInfo, timestamp, message);
                } else {
                    // Close any strategy block and add regular message
                    if (currentStrategyBlock) {
                        formattedOutput += formatStrategyBlock(currentStrategyBlock, blockBuffer);
                        blockBuffer = [];
                        currentStrategyBlock = null;
                    }

                    formattedOutput += formatLogEntry(cleanLog, logType, timestamp, message);
                }
            });

            // Close any remaining strategy block
            if (currentStrategyBlock) {
                formattedOutput += formatStrategyBlock(currentStrategyBlock, blockBuffer);
            }

            return formattedOutput || '<div class="log-entry log-info">Console initialized</div>';
        }

        function detectLogType(log) {
            const logUpper = log.toUpperCase();

            if (logUpper.includes('ERROR') || logUpper.includes('‚ùå') || logUpper.includes('FAILED')) {
                return 'error';
            } else if (logUpper.includes('WARNING') || logUpper.includes('‚ö†Ô∏è') || logUpper.includes('WARN')) {
                return 'warning';
            } else if (logUpper.includes('SUCCESS') || logUpper.includes('‚úÖ') || logUpper.includes('COMPLETED')) {
                return 'success';
            } else if (logUpper.includes('INFO') || logUpper.includes('‚ÑπÔ∏è') || logUpper.includes('üìä')) {
                return 'info';
            } else if (logUpper.includes('TRADE') || logUpper.includes('POSITION') || logUpper.includes('ORDER')) {
                return 'trade';
            } else if (logUpper.includes('STRATEGY') || logUpper.includes('SIGNAL') || logUpper.includes('ANALYSIS')) {
                return 'strategy';
            } else {
                return 'default';
            }
        }

        function detectCategory(log) {
            const logUpper = log.toUpperCase();

            if (logUpper.includes('TRADE') || logUpper.includes('POSITION') || logUpper.includes('ORDER') || logUpper.includes('BUY') || logUpper.includes('SELL')) {
                return 'trading';
            } else if (logUpper.includes('STRATEGY') || logUpper.includes('RSI') || logUpper.includes('MACD') || logUpper.includes('SIGNAL')) {
                return 'strategy';
            } else if (logUpper.includes('ERROR') || logUpper.includes('FAILED') || logUpper.includes('EXCEPTION')) {
                return 'error';
            } else if (logUpper.includes('API') || logUpper.includes('CONNECTION') || logUpper.includes('BINANCE')) {
                return 'system';
            } else if (logUpper.includes('BALANCE') || logUpper.includes('MARGIN') || logUpper.includes('PNL')) {
                return 'financial';
            } else {
                return 'general';
            }
        }

        function getCategoryIcon(category) {
            const icons = {
                'trading': 'üíπ',
                'strategy': 'üéØ',
                'error': 'üö®',
                'system': '‚öôÔ∏è',
                'financial': 'üí∞',
                'general': 'üìù'
            };
            return icons[category] || 'üìù';
        }

        function extractTimestamp(log) {
            // Try to extract timestamp patterns like [HH:MM:SS] or [YYYY-MM-DD HH:MM:SS]
            const timestampMatch = log.match(/\[([0-9]{1,4}[-:]?[0-9]{1,2}[-:]?[0-9]{1,2}[\s]?[0-9]{1,2}:[0-9]{2}:[0-9]{2})\]/);
            return timestampMatch ? timestampMatch[1] : null;
        }

        function extractMessage(log) {
            // Remove timestamp and clean the message
            let message = log.replace(/\[[0-9-:\s]+\]/, '').trim();

            // Remove log level prefixes
            message = message.replace(/^(ERROR|WARNING|INFO|DEBUG|SUCCESS)[\s:-]*/, '');

            return message;
        }

        function formatLogEntry(fullLog, type, timestamp, message, category = 'general') {
            const timeStr = timestamp ? `<span class="log-timestamp">${timestamp}</span>` : '';
            const typeIcon = getTypeIcon(type);

            return `
                <div class="log-entry log-${type}" data-category="${category}">
                    <div class="log-header">
                        ${timeStr}
                        <span class="log-type-icon">${typeIcon}</span>
                    </div>
                    <div class="log-message">${escapeHtml(message || fullLog)}</div>
                </div>
            `;
        }

        function getTypeIcon(type) {
            const icons = {
                'error': '‚ùå',
                'warning': '‚ö†Ô∏è',
                'success': '‚úÖ',
                'info': '‚ÑπÔ∏è',
                'trade': 'üíπ',
                'strategy': 'üéØ',
                'default': '‚Ä¢'
            };
            return icons[type] || '‚Ä¢';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function isStrategyScanning(log) {
            return log.includes('SCANNING') && (log.includes('|') || log.includes('Strategy:'));
        }

        function isActivePosition(log) {
            return log.includes('TRADE IN PROGRESS') || log.includes('ACTIVE POSITION');
        }

        function extractStrategyInfo(log) {
            const info = {
                strategy: 'UNKNOWN',
                symbol: '',
                timeframe: '',
                margin: '',
                leverage: '',
                price: '',
                indicator: ''
            };

            try {
                // Extract strategy name patterns
                let strategyMatch = log.match(/üîç SCANNING [A-Z]+ \| ([A-Z_]+)/);
                if (!strategyMatch) {
                    strategyMatch = log.match(/üìà SCANNING [A-Z]+ \| ([A-Z_]+)/);
                }
                if (!strategyMatch) {
                    strategyMatch = log.match(/Strategy: ([A-Z_]+)/);
                }

                if (strategyMatch) {
                    info.strategy = strategyMatch[1];
                }

                // Extract symbol
                const symbolMatch = log.match(/SCANNING ([A-Z]+)/);
                if (symbolMatch) {
                    info.symbol = symbolMatch[1];
                }

                // Extract timeframe
                const timeframeMatch = log.match(/(\d+[mh])/);
                if (timeframeMatch) {
                    info.timeframe = timeframeMatch[1];
                }

                // Extract margin and leverage
                const marginMatch = log.match(/\$(\d+\.?\d*)/);
                if (marginMatch) {
                    info.margin = marginMatch[1];
                }

                const leverageMatch = log.match(/(\d+)x/);
                if (leverageMatch) {
                    info.leverage = leverageMatch[1];
                }

                // Extract price
                const priceMatch = log.match(/Price: \$([0-9,]+\.?\d*)/);
                if (priceMatch) {
                    info.price = priceMatch[1];
                }

                // Extract indicator (RSI or MACD)
                const rsiMatch = log.match(/RSI: ([\d\.]+)/);
                const macdMatch = log.match(/MACD: ([-\d\.]+)\/([-\d\.]+)/);
                const histogramMatch = log.match(/H: ([-\d\.]+)/);

                if (rsiMatch) {
                    info.indicator = `RSI: ${rsiMatch[1]}`;
                } else if (macdMatch && histogramMatch) {
                    info.indicator = `MACD: ${macdMatch[1]}/${macdMatch[2]} | H: ${histogramMatch[1]}`;
                }

            } catch (e) {
                // Fallback to basic parsing
            }

            return info;
        }

        function extractPositionInfo(log) {
            const info = {
                strategy: '',
                symbol: '',
                side: '',
                entry: '',
                current: '',
                pnl: '',
                indicator: ''
            };

            try {
                const strategyMatch = log.match(/Strategy: ([A-Z_]+)/);
                if (strategyMatch) info.strategy = strategyMatch[1];

                const symbolMatch = log.match(/Symbol: ([A-Z]+)/);
                if (symbolMatch) info.symbol = symbolMatch[1];

                const sideMatch = log.match(/Side: ([A-Z]+)/);
                if (sideMatch) info.side = sideMatch[1];

                const entryMatch = log.match(/Entry: \$([0-9,]+\.?\d*)/);
                if (entryMatch) info.entry = entryMatch[1];

                const currentMatch = log.match(/Current: \$([0-9,]+\.?\d*)/);
                if (currentMatch) info.current = currentMatch[1];

                const pnlMatch = log.match(/PnL: \$([+-]?[0-9,]+\.?\d*) USDT \(([+-]?[\d\.]+)%\)/);
                if (pnlMatch) info.pnl = `$${pnlMatch[1]} (${pnlMatch[2]}%)`;

                const indicatorMatch = log.match(/Indicator: ([^‚ïë]+)/);
                if (indicatorMatch) info.indicator = indicatorMatch[1].trim();
            } catch (e) {
                // Fallback
            }

            return info;
        }

        function formatStrategyBlock(strategy, blockData) {
            if (!blockData || blockData.length === 0) return '';

            const strategyColor = getStrategyColor(strategy);
            const latestData = blockData[blockData.length - 1].data;
            const timestamp = blockData[blockData.length - 1].timestamp;

            return `
                <div class="log-entry log-strategy-block" style="border-left-color: ${strategyColor}; background: linear-gradient(90deg, ${strategyColor}15, transparent);">
                    <div class="strategy-block-header" style="color: ${strategyColor};">
                        <span class="log-timestamp">${timestamp}</span>
                        <span class="strategy-name">üîç ${strategy} SCANNING</span>
                    </div>
                    <div class="strategy-block-content">
                        <div class="strategy-data-row">üí± Symbol: <span style="color: ${strategyColor};">${latestData.symbol}</span></div>
                        <div class="strategy-data-row">‚è±Ô∏è Timeframe: <span style="color: ${strategyColor};">${latestData.timeframe}</span></div>
                        <div class="strategy-data-row">üíµ Margin: <span style="color: ${strategyColor};">$${latestData.margin} USDT</span></div>
                        <div class="strategy-data-row">‚ö° Leverage: <span style="color: ${strategyColor};">${latestData.leverage}x</span></div>
                        <div class="strategy-data-row">üìä Price: <span style="color: ${strategyColor};">$${latestData.price}</span></div>
                        ${latestData.indicator ? `<div class="strategy-data-row">üìà ${latestData.indicator}</div>` : ''}
                    </div>
                </div>
            `;
        }

        function formatActivePositionBlock(positionInfo, timestamp, message) {
            const strategyColor = getStrategyColor(positionInfo.strategy);
            const pnlColor = positionInfo.pnl && positionInfo.pnl.includes('+') ? '#2ed573' : '#ff4757';

            return `
                <div class="log-entry log-position-block" style="border: 2px solid ${strategyColor}; background: linear-gradient(135deg, ${strategyColor}20, transparent);">
                    <div class="position-block-header" style="color: ${strategyColor};">
                        <span class="log-timestamp">${timestamp}</span>
                        <span class="position-title">üìä ACTIVE POSITION</span>
                    </div>
                    <div class="position-block-content">
                        <div class="position-data-row">üéØ Strategy: <span style="color: ${strategyColor}; font-weight: bold;">${positionInfo.strategy}</span></div>
                        <div class="position-data-row">üí± Symbol: <span style="color: ${strategyColor};">${positionInfo.symbol}</span></div>
                        <div class="position-data-row">üìä Side: <span style="color: ${strategyColor};">${positionInfo.side}</span></div>
                        <div class="position-data-row">üíµ Entry: <span style="color: ${strategyColor};">$${positionInfo.entry}</span></div>
                        <div class="position-data-row">üìä Current: <span style="color: ${strategyColor};">$${positionInfo.current}</span></div>
                        ${positionInfo.indicator ? `<div class="position-data-row">üìà ${positionInfo.indicator}</div>` : ''}
                        ${positionInfo.pnl ? `<div class="position-data-row">üí∞ PnL: <span style="color: ${pnlColor}; font-weight: bold;">${positionInfo.pnl}</span></div>` : ''}
                    </div>
                </div>
            `;
        }

        function getStrategyColor(strategy) {
            const colors = {
                'RSI_OVERSOLD': '#e74c3c',
                'RSI_ETH': '#3498db', 
                'MACD_DIVERGENCE': '#9b59b6',
                'MACD_BTC': '#f39c12',
                'DEFAULT': '#95a5a6'
            };
            return colors[strategy] || colors['DEFAULT'];
        }

        function updateConsoleLogErrorUI() {
            const consoleLog = document.getElementById('consoleLog');
            if (consoleLog) {
                consoleLog.innerHTML = '<div class="text-warning">‚ö†Ô∏è Connection lost - Reconnecting...</div>';
            }
        }

        // Update positions with intelligent caching and throttling
        function updatePositions() {
            // Check cache first
            const cachedData = getCachedData('positions');
            if (cachedData) {
                updatePositionsUI(cachedData);
                return;
            }

            // Check if we can make a new request
            if (!canMakeRequest('positions')) {
                return; // Skip this update cycle
            }

            markRequestStart('positions');

            fetch('/api/positions')
                .then(response => response.json())
                .then(data => {
                    setCachedData('positions', data);
                    updatePositionsUI(data);
                })
                .catch(error => {
                    console.error('Error updating positions:', error);
                    document.getElementById('positionsTableBody').innerHTML = '<tr><td colspan="9" class="text-warning text-center">Error loading positions</td></tr>';
                })
                .finally(() => {
                    markRequestEnd('positions');
                });
        }

        function updatePositionsUI(data) {
            const positionsTableBody = document.getElementById('positionsTableBody');
            positionsTableBody.innerHTML = '';

            if (data.success && data.positions && data.positions.length > 0) {
                data.positions.forEach(function(position) {
                    // Validate and sanitize position data
                    const entryPrice = position.entry_price || 0;
                    const currentPrice = position.current_price || 0;
                    const pnl = position.pnl || 0;
                    const pnlPercent = position.pnl_percent || 0;

                    const row = '<tr>' +
                            '<td>' + (position.strategy || 'Unknown') + '</td>' +
                            '<td>' + (position.symbol || 'Unknown') + '</td>' +
                            '<td>' + (position.side || 'Unknown') + '</td>' +
                            '<td>' + formatNumber(entryPrice) + '</td>' +
                            '<td>' + formatNumber(position.margin_invested || 0) + '</td>' +
                            '<td>' + formatNumber(currentPrice) + '</td>' +
                            '<td class="' + (pnl >= 0 ? 'text-success' : 'text-danger') + '">' + formatNumber(pnl) + '</td>' +
                            '<td class="' + (pnlPercent >= 0 ? 'text-success' : 'text-danger') + '">' + formatNumber(pnlPercent) + '%</td>' +
                            '<td id="rsi-' + data.positions.indexOf(position) + '">Loading...</td>' +
                        '</tr>';
                    positionsTableBody.innerHTML += row;
                });

                // Fetch RSI values for each position after rendering the table
                data.positions.forEach(function(position, index) {
                    fetchRSI(position.symbol, index);
                });
            } else {
                positionsTableBody.innerHTML = '<tr><td colspan="9" class="text-muted text-center">No active positions.</td></tr>';
            }
        }


        function fetchRSI(symbol, index) {
            fetch('/api/rsi/' + symbol)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('HTTP ' + response.status);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success && data.rsi !== undefined) {
                        let rsiValue = data.rsi;
                        let rsiClass = 'bg-secondary';
                        let rsiText = 'RSI: ' + rsiValue;

                        // Add note indicator if it's estimated/fallback
                        if (data.note) {
                            rsiText += ' (~)';
                        }

                        // Color code RSI values
                        if (rsiValue <= 30) {
                            rsiClass = 'bg-success'; // Oversold - green
                        } else if (rsiValue >= 70) {
                            rsiClass = 'bg-danger'; // Overbought - red
                        } else if (rsiValue <= 40) {
                            rsiClass = 'bg-info'; // Low - blue
                        } else if (rsiValue >= 60) {
                            rsiClass = 'bg-warning'; // High - yellow
                        }

                        const rsiElement = document.getElementById('rsi-' + index);
                        if (rsiElement) {
                            rsiElement.className = `badge ${rsiClass}`;
                            rsiElement.textContent = rsiText;
                        }
                    } else {
                        const rsiElement = document.getElementById('rsi-' + index);
                        if (rsiElement) {
                            rsiElement.className = 'badge bg-danger';
                            rsiElement.textContent = 'RSI: Error';
                            rsiElement.title = data.error || 'Failed to calculate RSI';
                        }
                    }
                })
                .catch(error => {
                    console.debug('RSI fetch error for ' + symbol + ':', error);
                    const rsiElement = document.getElementById('rsi-' + index);
                    if (rsiElement) {
                        rsiElement.className = 'badge bg-secondary';
                        rsiElement.textContent = 'RSI: --';
                        rsiElement.title = 'RSI calculation in progress';
                    }
                });
        }

        // Initialize dashboard with intelligent adaptive polling system
        let updateTimeouts = {};
        let pollingActive = true;

         // Simple API request function without complex error handling
        function apiRequest(url) {
            return fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('HTTP ' + response.status);
                    }
                    return response.json();
                })
                .catch(error => {
                    console.error('API request failed:', error);
                    return { success: false, error: error.message };
                });
        }

        // FIXED: Enhanced safe API response handler to prevent parsing errors
        function safeApiCall(url, options = {}) {
            return fetch(url, options)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                    }

                    // Get content type to validate JSON response
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        throw new Error('Invalid content type - expected JSON');
                    }

                    return response.text();
                })
                .then(text => {
                    if (!text || text.trim() === '') {
                        return getDefaultResponse(url);
                    }

                    try {
                        const data = JSON.parse(text);
                        // Validate that we got an object
                        if (!data || typeof data !== 'object') {
                            return getDefaultResponse(url);
                        }
                        return data;
                    } catch (parseError) {
                        console.warn('JSON parse error for', url, ':', parseError.message);
                        return getDefaultResponse(url);
                    }
                })
                .catch(error => {
                    console.warn('API call failed for', url, ':', error.message);
                    return getDefaultResponse(url);
                });
        }

        function getDefaultResponse(url){
            const currentTime = new Date().toLocaleTimeString();

            if (url.includes('/api/bot/status') || url.includes('/api/bot_status')) {
                return {
                    success: true,
                    running: false,
                    is_running: false,
                    active_positions: 0,
                    strategies: 0,
                    balance: 0.0,
                    status: 'api_fallback',
                    last_update: currentTime,
                    timestamp: currentTime
                };
            } else if (url.includes('/api/console-log')) {
                return {
                    success: true,
                    logs: ['[' + currentTime + '] üîÑ API temporarily unavailable'],
                    status: 'api_fallback',
                    timestamp: currentTime
                };
            } else if (url.includes('/api/positions')) {
                return {
                    success: true,
                    positions: [],
                    status: 'api_fallback',
                    count: 0,
                    timestamp: currentTime
                };
            } else if (url.includes('/api/balance')) {
                return {
                    success: true,
                    total_balance: 0.0,
                    available_balance: 0.0,
                    used_balance: 0.0,
                    last_updated: new Date().toISOString(),
                    status: 'api_fallback'
                };
            }

            return { success: false, error: 'Unknown endpoint' };
        }

        // FIXED: Enhanced intelligent update system with adaptive intervals
        function startIntelligentUpdates() {
            // Clear any existingtimeouts
            Object.values(updateTimeouts).forEach(timeout => clearTimeout(timeout));
            updateTimeouts = {};

            pollingActive = true;

            // Start adaptive polling loops
            scheduleAdaptiveUpdate('botStatus', updateBotStatus);
            scheduleAdaptiveUpdate('balance', updateBalance);
            scheduleAdaptiveUpdate('consoleLog', updateConsoleLog);
            scheduleAdaptiveUpdate('positions', updatePositions);
        }

        function scheduleAdaptiveUpdate(key, updateFunction) {
            if (!pollingActive) return;

            const executeUpdate = () => {
                if (!pollingActive) return;

                // Execute the update function with proper error handling
                try {
                    Promise.resolve(updateFunction())
                        .then(() => {
                            // Schedule next update only if polling is still active
                            if (pollingActive) {
                                const interval = calculateAdaptiveInterval(key);
                                updateTimeouts[key] = setTimeout(executeUpdate, interval);
                            }
                        })
                        .catch(error => {
                            console.error('Update error for ' + key + ':', error || 'Unknown error');
                            // Still schedule next update even if current one failed
                            if (pollingActive) {
                                const interval = Math.min(calculateAdaptiveInterval(key) * 2, 30000); // Backoff on error
                                updateTimeouts[key] = setTimeout(executeUpdate, interval);
                            }
                        });
                } catch (syncError) {
                    console.error('Synchronous error for ' + key + ':', syncError || 'Unknown sync error');
                    // Still schedule next update
                    if (pollingActive) {
                        const interval = Math.min(calculateAdaptiveInterval(key) * 2, 30000);
                        updateTimeouts[key] = setTimeout(executeUpdate, interval);
                    }
                }
            };

            // Start immediately
            executeUpdate();
        }

        function stopIntelligentUpdates() {
            pollingActive = false;            Object.values(updateTimeouts).forEach(timeout => clearTimeout(timeout));
            updateTimeouts = {};
        }

        // Refresh data function with complete cache invalidation and adaptive reset
        function refreshData() {
            // Clear all caches to force fresh data
            Object.keys(apiCache).forEach(key => {
                apiCache[key].data = null;
                apiCache[key].timestamp = 0;
                apiCache[key].consecutiveHits = 0;
                apiCache[key].ttl = key === 'botStatus' ? 8000 :
                                   key === 'balance' ? 30000 :
                                   key === 'positions' ? 12000 : 5000;
            });

            // Reset throttle timers and intervals
            Object.keys(requestThrottle).forEach(key => {
                requestThrottle[key].lastRequest = 0;
                requestThrottle[key].currentInterval = requestThrottle[key].minInterval;
            });

            // Reset adaptive behavior
            connectionState = 'healthy';
            inactivityCount = 0;

            // Clear active requests set
            activeRequests.clear();

            // Force immediate updates
            Promise.allSettled([
                updateBotStatus(),
                updateBalance(),
                updateConsoleLog(),
                updatePositions()
            ]).then(() => {
                console.log('üîÑ Dashboard refresh completed');
            });
        }

        // Simple dashboard initialization
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ Dashboard initialization started');

            // Initial data load
            updateBotStatus();
            updateBalance();
            updateConsoleLog();
            updatePositions();

            // Set up regular updates
            setInterval(updateBotStatus, 8000);    // 8 seconds
            setInterval(updateBalance, 30000);     // 30 seconds
            setInterval(updateConsoleLog, 5000);   // 5 seconds
            setInterval(updatePositions, 12000);   // 12 seconds

            console.log('‚úÖ Dashboard initialized with simple polling');
        });

            // Handle visibility changes to optimize resource usage
            document.addEventListener('visibilitychange', function() {
                if (document.hidden) {
                    console.log('üëÅÔ∏è Tab hidden - optimizing polling for background mode');
                    // Slow down polling when tab is not visible
                    Object.keys(requestThrottle).forEach(key => {
                        requestThrottle[key].currentInterval = requestThrottle[key].maxInterval;
                    });
                } else {
                    console.log('üëÅÔ∏è Tab visible - resuming normal polling');
                    // Resume normal polling and refresh data
                    Object.keys(requestThrottle).forEach(key => {
                        requestThrottle[key].currentInterval = requestThrottle[key].minInterval;
                    });

                    // Refresh all data when tab becomes visible
                    Promise.allSettled([
                        updateBotStatus(),
                        updateBalance(),
                        updateConsoleLog(),
                        updatePositions()
                    ]).then(() => {
                        console.log('üîÑ Dashboard refresh completed');
                    });
                }
            });

            // FIXED: Add comprehensive error handler for API response parsing errors
            window.addEventListener('error', function(event) {
                if (event.message && (
                    event.message.includes('Unexpected end of input') ||
                    event.message.includes('JSON.parse') ||
                    event.message.includes('SyntaxError')
                )) {
                    console.log('üîß Suppressed parsing error - continuing normally');
                    event.preventDefault();
                    return false;
                }
            });

            // FIXED: Add comprehensive promise rejection handler
            window.addEventListener('unhandledrejection', function(event) {
                if (event.reason && event.reason.message && (
                    event.reason.message.includes('Unexpected end of input') ||
                    event.reason.message.includes('JSON.parse') ||
                    event.reason.message.includes('SyntaxError')
                )) {
                    console.log('üîß Suppressed parsing rejection - continuing normally');
                    event.preventDefault();
                    return false;
                }
            });

            // Cleanup on page unload
            window.addEventListener('beforeunload', function() {
                stopIntelligentUpdates();
            });


        // Show strategies info
        function showStrategiesInfo() {
            alert('Check the Strategy Configuration table below for current settings.');
        }

        // Show console info
        function showConsoleInfo() {
            alert('Console shows real-time bot activity:\n\n' +
                  '‚Ä¢ Green messages: Successful operations\n' +
                  '‚Ä¢ Red messages: Errors or warnings\n' +
                  '‚Ä¢ Blue messages: Information\n' +
                  '‚Ä¢ Yellow messages: Market analysis\n\n' +
                  'Auto-scroll keeps the latest messages visible.');
        }

        // Load strategies with cache busting
        function loadStrategiesWithCacheBust() {
            const timestamp = new Date().getTime();
            fetch('/api/strategies?_t=' + timestamp)
                .then(response => response.json())
                .then(strategies => {
                    // Update global strategies cache
                    window.strategiesData = strategies;
                    window.strategiesCache = strategies;
                    console.log('üîÑ Strategies data refreshed with latest configurations');
                })
                .catch(error => {
                    console.error('Error refreshing strategies:', error);
                });
        }

        // Edit strategy configuration
        function editStrategy(strategyName) {
            // Force fresh data fetch with timestamp to bypass cache
            const timestamp = new Date().getTime();
            fetch('/api/strategies?_t=' + timestamp)
                .then(response => response.json())
                .then(strategies => {
                    const config = strategies[strategyName];
                    if (config) {
                        editStrategyConfig(strategyName);
                    } else {
                        alert('Strategy not found: ' + strategyName);
                    }
                })
                .catch(error => {
                    console.error('Error loading strategy:', error);
                    alert('Error loading strategy: ' + error);
                });
        }

        // View strategy statistics function
        function viewStrategyStats(strategyName) {
            alert('üìä Strategy Statistics for ' + strategyName.replace('_', ' ').toUpperCase() + '\n\n' +
                  'Feature coming soon!\n\n' +
                  '‚Ä¢ Trade success rate\n' +
                  '‚Ä¢ Average profit/loss\n' +
                  '‚Ä¢ Performance over time\n' +
                  '‚Ä¢ Risk metrics');
        }

        // Disable strategy
        function disableStrategy(strategyName) {
            if (confirm('Are you sure you want to disable this strategy?')) {
                console.log('üî¥ Disabling strategy:', strategyName);

                fetch('/api/strategy/' + strategyName + '/disable', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                })
                .then(response => {
                    console.log('Disable response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('Disable response data:', data);
                    if (data.success) {
                        // Update UI immediately
                        updateStrategyStatusBadge(strategyName, 'disabled');
                        updateStrategyToggleButton(strategyName, 'disabled');

                        // Store state in localStorage for persistence
                        localStorage.setItem(`strategy_${strategyName}_state`, 'disabled');

                        showNotification('Strategy ' + strategyName + ' disabled successfully', 'success');
                        refreshStrategies(); // Refresh the entire strategies display
                    } else {
                        showNotification('Failed to disable strategy: ' + (data.error || 'Unknown error'), 'error');
                    }
                })
                .catch(error => {
                    console.error('Error disabling strategy:', error);
                    showNotification('Error disabling strategy: ' + error.message, 'error');
                });
            }
        }

        // Enable strategy
        function enableStrategy(strategyName) {
            console.log('üü¢ Enabling strategy:', strategyName);

            fetch('/api/strategy/' + strategyName + '/enable', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => {
                console.log('Enable response status:', response.status);
                return response.json();
            })
            .then(data => {
                console.log('Enable response data:', data);
                if (data.success) {
                    // Update UI immediately
                    updateStrategyStatusBadge(strategyName, 'enabled');
                    updateStrategyToggleButton(strategyName, 'enabled');

                    // Store state in localStorage for persistence
                    localStorage.setItem(`strategy_${strategyName}_state`, 'enabled');

                    showNotification('Strategy ' + strategyName + ' enabled successfully', 'success');
                    refreshStrategies(); // Refresh the entire strategies display
                } else {
                    showNotification('Failed to enable strategy: ' + (data.error || 'Unknown error'), 'error');
                }
            })
            .catch(error => {
                console.error('Error enabling strategy:', error);
                showNotification('Error enabling strategy: ' + error.message, 'error');
            });
        }

        // Helper functions to update UI elements after enable/disable actions
        function updateStrategyStatusBadge(strategyName, state) {
            const badge = document.querySelector(`.card:contains("${strategyName}") .badge`);
            if (badge) {
                badge.textContent = state === 'enabled' ? 'Active' : 'Disabled';
                badge.className = `badge bg-${state === 'enabled' ? 'success' : 'secondary'}`;
            }
        }

        function updateStrategyToggleButton(strategyName, state) {
            const button = document.querySelector(`.card:contains("${strategyName}") .strategy-toggle-btn`);
            if (button) {
                button.textContent = state === 'enabled' ? 'Disable' : 'Enable';
                button.className = `btn btn-outline-${state === 'enabled' ? 'danger' : 'success'} btn-sm strategy-toggle-btn`;
                button.setAttribute('onclick', `${state === 'enabled' ? 'disableStrategy' : 'enableStrategy'}('${strategyName}')`);
            }
        }

        // Refresh the strategies list (dummy function for now)
        function refreshStrategies() {
            // Implement actual refresh logic here, e.g., re-fetch strategies data from the API
            console.log('üîÑ Refreshing strategies list (not fully implemented)');
        }

        // Show a notification message
        function showNotification(message, type) {
            // Implement notification logic here, e.g., display a toast or alert message
            console.log(`üì£ Notification: ${message} (Type: ${type})`);
        }

        // Strategy management functions
        let currentStrategyName = '';

        function togglePartialTpConfig() {
            const toggle = document.getElementById('partialTpEnabled');
            const configSection = document.getElementById('partialTpConfigSection');
            const thresholdInput = document.getElementById('partialTpPnlThreshold');
            const positionInput = document.getElementById('partialTpPositionPercentage');
            const exampleDiv = document.getElementById('partialTpExample');

            if (toggle.checked) {
                // Enable partial TP configuration
                configSection.style.opacity = '1';
                configSection.style.pointerEvents = 'auto';
                thresholdInput.disabled = false;
                positionInput.disabled = false;

                // Set default values if empty
                if (!thresholdInput.value) {
                    thresholdInput.value = 50;
                }
                if (!positionInput.value) {
                    positionInput.value = 50;
                }

                console.log('‚úÖ Partial TP enabled - configuration unlocked');
            } else {
                // Disable partial TP configuration
                configSection.style.opacity = '0.5';
                configSection.style.pointerEvents = 'none';
                thresholdInput.disabled = true;
                positionInput.disabled = true;

                // Clear values when disabled to prevent accidental saving
                thresholdInput.value = '';
                positionInput.value = '';

                console.log('‚ùå Partial TP disabled - configuration locked');
            }

            // Update example calculation
            updatePartialTpExample();
        }

        function updatePartialTpExample() {
            const toggle = document.getElementById('partialTpEnabled');
            const threshold = document.getElementById('partialTpPnlThreshold').value;
            const position = document.getElementById('partialTpPositionPercentage').value;
            const exampleDiv = document.getElementById('partialTpExample');

            if (toggle.checked && threshold && position) {
                exampleDiv.innerHTML = `
                    <small>
                        <strong>Your Configuration:</strong> ${threshold}% PnL threshold, ${position}% position size<br>
                        ‚Ä¢ When profit reaches ${threshold}% of margin ‚Üí Close ${position}% of position<br>
                        ‚Ä¢ Remaining ${100 - position}% continues until stop loss or manual exit
                    </small>
                `;
                exampleDiv.className = 'alert alert-success mt-2';
            } else if (toggle.checked) {
                exampleDiv.innerHTML = `
                    <small>
                        <strong>Example:</strong> With 50% PnL threshold and 50% position size:<br>
                        ‚Ä¢ When profit reaches 50% of margin ‚Üí Close 50% of position<br>
                        ‚Ä¢ Remaining 50% continues until stop loss or manual exit
                    </small>
                `;
                exampleDiv.className = 'alert alert-info mt-2';
            } else {
                exampleDiv.innerHTML = `
                    <small>
                        <strong>Partial Take Profit is disabled.</strong><br>
                        Enable the toggle above to configure automatic partial profit taking.
                    </small>
                `;
                exampleDiv.className = 'alert alert-secondary mt-2';
            }
        }

        function editStrategyConfig(strategyName) {
            currentStrategyName = strategyName;

            fetch('/api/strategies')
                .then(response => response.json())
                .then(data => {
                    const config = data[strategyName];
                    if (config) {
                        // Basic parameters
                        document.getElementById('strategyName').value = strategyName;
                        document.getElementById('strategySymbol').value = config.symbol || '';
                        document.getElementById('strategyMargin').value = config.margin || '';
                        document.getElementById('strategyLeverage').value = config.leverage || '';
                        document.getElementById('strategyDecimals').value = config.decimals || 2;
                        document.getElementById('strategyTimeframe').value = config.timeframe || '';
                        document.getElementById('strategyMaxLoss').value = config.max_loss_pct || 10;
                        document.getElementById('assessmentInterval').value = config.assessment_interval || 300;
                        if (config.cooldown_period !== undefined) {
                                document.getElementById('cooldownPeriod').value = config.cooldown_period;
                            }

                            // Partial Take Profit Configuration
                            const hasPartialTpConfig = config.partial_tp_pnl_threshold !== undefined && 
                                                     config.partial_tp_position_percentage !== undefined &&
                                                     config.partial_tp_pnl_threshold > 0 && 
                                                     config.partial_tp_position_percentage > 0;

                            const partialTpToggle = document.getElementById('partialTpEnabled');
                            partialTpToggle.checked = hasPartialTpConfig;

                            if (hasPartialTpConfig) {
                                document.getElementById('partialTpPnlThreshold').value = config.partial_tp_pnl_threshold;
                                document.getElementById('partialTpPositionPercentage').value = config.partial_tp_position_percentage;
                            } else {
                                document.getElementById('partialTpPnlThreshold').value = '';
                                document.getElementById('partialTpPositionPercentage').value = '';
                            }

                            // Apply toggle state
                            togglePartialTpConfig();

                        // Hide all strategy-specific sections first
                        document.getElementById('rsiParameters').style.display = 'none';
                        document.getElementById('macdParameters').style.display = 'none';

                        // Show and populate RSI parameters if it's an RSI strategy
                        if (strategyName.toLowerCase().includes('rsi')){
                            document.getElementById('rsiParameters').style.display = 'block';
                            document.getElementById('rsiLongEntry').value = config.rsi_long_entry || 40;
                            document.getElementById('rsiLongExit').value = config.rsi_long_exit || 70;
                            document.getElementById('rsiShortEntry').value = config.rsi_short_entry || 60;
                            document.getElementById('rsiShortExit').value = config.rsi_short_exit || 30;
                        }

                        // Show and populate MACD parameters if it's a MACD strategy
                        if (strategyName.toLowerCase().includes('macd')) {
                            document.getElementById('macdParameters').style.display = 'block';
                            document.getElementById('macdFast').value = config.macd_fast || 12;
                            document.getElementById('macdSlow').value = config.macd_slow || 26;
                            document.getElementById('macdSignal').value = config.macd_signal || 9;
                            document.getElementById('minHistogramThreshold').value = config.min_histogram_threshold || 0.0001;
                            document.getElementById('macdEntryThreshold').value = config.macd_entry_threshold || config.min_distance_threshold || 0.0015;
                            document.getElementById('macdExitThreshold').value = config.macd_exit_threshold || 0.002;
                            document.getElementById('histogramDivergenceLookback').value = config.histogram_divergence_lookback || 10;
                            document.getElementById('priceDivergenceLookback').value = config.price_divergence_lookback || 10;
                            document.getElementById('confirmationCandles').value = config.confirmationCandles || 2;
                            document.getElementById('divergenceStrengthMin').value = config.divergence_strength_min || 0.4;
                        }

                        // Show modal using Bootstrap 5
                        const modal = new bootstrap.Modal(document.getElementById('strategyModal'));
                        modal.show();
                    } else {
                        alert('Strategy configuration not found.');
                    }
                })
                .catch(error => console.error('Error fetching strategy config:', error));
        }

        // Save strategy configuration
        function saveStrategyConfig() {
            const strategyName = document.getElementById('strategyName').value;

            const updates = {
                symbol: document.getElementById('strategySymbol').value,
                margin: parseFloat(document.getElementById('strategyMargin').value),
                leverage: parseInt(document.getElementById('strategyLeverage').value),
                decimals: parseInt(document.getElementById('strategyDecimals').value),
                timeframe: document.getElementById('strategyTimeframe').value,
                max_loss_pct: parseFloat(document.getElementById('strategyMaxLoss').value),
                assessment_interval: parseInt(document.getElementById('assessmentInterval').value),
                cooldown_period: parseInt(document.getElementById('cooldownPeriod').value)
            };

            // Partial Take Profit Configuration
            const partialTpEnabled = document.getElementById('partialTpEnabled').checked;

            if (partialTpEnabled) {
                const threshold = document.getElementById('partialTpPnlThreshold').value;
                const positionSize = document.getElementById('partialTpPositionPercentage').value;

                if (threshold && positionSize) {
                    updates.partial_tp_pnl_threshold = parseFloat(threshold);
                    updates.partial_tp_position_percentage = parseFloat(positionSize);
                    console.log('‚úÖ Partial TP config saved:', updates.partial_tp_pnl_threshold + '% threshold, ' + updates.partial_tp_position_percentage + '% position');
                } else {
                    alert('‚ö†Ô∏è Partial TP is enabled but missing configuration values.\nPlease fill both threshold and position size, or disable partial TP.');
                    return;
                }
            } else {
                // Explicitly disable partial TP by setting to 0
                updates.partial_tp_pnl_threshold = 0;
                updates.partial_tp_position_percentage = 0;
                console.log('‚ùå Partial TP disabled - saved as 0');
            }

            // Add strategy-specific parameters
            if (strategyName.toLowerCase().includes('rsi')) {
                updates.rsi_long_entry = parseInt(document.getElementById('rsiLongEntry').value);
                updates.rsi_long_exit = parseInt(document.getElementById('rsiLongExit').value);
                updates.rsi_short_entry = parseInt(document.getElementById('rsiShortEntry').value);
                updates.rsi_short_exit = parseInt(document.getElementById('rsiShortExit').value);
            }

             if (strategyName.toLowerCase().includes('macd')) {
                updates.macd_fast = parseInt(document.getElementById('macdFast').value);
                updates.macd_slow = parseInt(document.getElementById('macdSlow').value);
                updates.macd_signal = parseInt(document.getElementById('macdSignal').value);
                updates.min_histogram_threshold = parseFloat(document.getElementById('minHistogramThreshold').value);
                updates.macd_entry_threshold = parseFloat(document.getElementById('macdEntryThreshold').value);
                updates.macd_exit_threshold = parseFloat(document.getElementById('macdExitThreshold').value);
                updates.histogram_divergence_lookback = parseInt(document.getElementById('histogramDivergenceLookback').value);
                updates.price_divergence_lookback = parseInt(document.getElementById('priceDivergenceLookback').value);
                updates.confirmation_candles = parseInt(document.getElementById('confirmationCandles').value);
                updates.divergence_strength_min = parseFloat(document.getElementById('divergenceStrengthMin').value);
            }

             // Safety validation to prevent zero entries
             if (updates.margin <= 0 || updates.leverage <= 0 || updates.max_loss_pct <= 0 || updates.assessment_interval <= 0 || updates.cooldown_period <= 0) {
                alert('Error: Critical parameters (margin, leverage, max loss %, assessment interval, cooldown period) cannot be zero.');
                return;
            }

            fetch('/api/strategies/' + strategyName, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(updates)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Always show success message first
                    showAlert('Configuration saved successfully!', 'success');

                    // Close the modal immediately on success
                    const modal = bootstrap.Modal.getInstance(document.getElementById('strategyModal'));
                    if (modal) {
                        modal.hide();
                    }

                    // Handle safety validation feedback after closing modal
                    handleSafetyValidation(data);

                    // Reload strategies to show updated config
                    loadStrategiesWithCacheBust();
                } else {
                    alert('Error updating strategy: ' + data.message);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error saving configuration: ' + error.message);
            });
        }

        // Add new strategy function
        function addNewStrategy() {
            // Reset form
            document.getElementById('addStrategyForm').reset();

            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('addStrategyModal'));
            modal.show();
        }

        // Save new strategy
        function saveNewStrategy() {
            const name = document.getElementById('newStrategyName').value.trim();

            if (!name) {
                alert('Strategy name is required');
                return;
            }

            if (!name.toLowerCase().includes('rsi') && !name.toLowerCase().includes('macd')) {
                alert('Strategy name must contain "rsi" or "macd" to determine strategy type');
                return;
            }

            const symbol = document.getElementById('newStrategySymbol').value.trim();
            if (!symbol) {
                alert('Symbol is required');
                return;
            }

            const newStrategy = {
                name: name,
                symbol: symbol.toUpperCase(),
                margin: parseFloat(document.getElementById('newStrategyMargin').value),
                leverage: parseInt(document.getElementById('newStrategyLeverage').value),
                timeframe: document.getElementById('newStrategyTimeframe').value,
                max_loss_pct: parseFloat(document.getElementById('newStrategyMaxLoss').value),
                assessment_interval: parseInt(document.getElementById('newStrategyInterval').value),
                cooldown_period: parseInt(document.getElementById('newStrategyCooldown').value)
            };

            // Add strategy-specific parameters
            if (name.toLowerCase().includes('rsi')) {
                newStrategy.rsi_long_entry = 30;
                newStrategy.rsi_long_exit = 70;
                newStrategy.rsi_short_entry = 70;
                newStrategy.rsi_short_exit = 30;
            } else if (name.toLowerCase().includes('macd')) {
                newStrategy.macd_fast = 12;
                newStrategy.macd_slow = 26;
                newStrategy.macd_signal = 9;
                newStrategy.divergence_strength_min = 0.6;
            }

             // Safety validation to prevent zero entries
             if (newStrategy.margin <= 0 || newStrategy.leverage <= 0 || newStrategy.max_loss_pct <= 0 || newStrategy.assessment_interval <= 0 || newStrategy.cooldown_period <= 0) {
                alert('Error: Critical parameters (margin, leverage, max loss %, assessment interval, cooldown period) cannot be zero.');
                return;
            }

            fetch('/api/strategies', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(newStrategy)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Close modal
                    const modal = bootstrap.Modal.getInstance(document.getElementById('addStrategyModal'));
                    if (modal) {
                        modal.hide();
                    }

                    alert('‚úÖ Strategy created successfully!\n\n' +
                          '‚Ä¢ Strategy: ' + data.strategy.symbol + '\n' +
                          '‚Ä¢ Margin: $' + data.strategy.margin + ' USDT\n' +
                          '‚Ä¢ Leverage: ' + data.strategy.leverage + 'x\n\n' +
                          'The strategy will be active when the bot restarts.');

                    // Refresh the page to show new strategy
                    location.reload();
                } else {
                    alert('‚ùå Error creating strategy:\n\n' + data.message);
                }
            })
            .catch(error => {
                console.error('Error creating strategy:', error);
                alert('Error creating strategy: ' + error);
            });
        }

        // Console log functions
        function clearConsoleLog() {
            const consoleLog = document.getElementById('consoleLog');
            if (consoleLog) {
                consoleLog.innerHTML = '<div class="text-muted">Console cleared</div>';
            }
        }

        function toggleAutoScroll() {
            autoScroll = !autoScroll;
            const btn = document.getElementById('autoScrollBtn');
            if (btn) {
                btn.innerHTML = autoScroll ?
                    '<i class="fas fa-arrows-alt-v"></i> Auto-scroll: ON' :
                    '<i class="fas fa-arrows-alt-v"></i> Auto-scroll: OFF';
            }
        }

        // Show alert function for better user feedback
        function showAlert(message, type) {
            // Remove existing alerts
            const existingAlerts = document.querySelectorAll('.dynamic-alert');
            existingAlerts.forEach(function(alert) { alert.remove(); });

            // Create new alert
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type === 'success' ? 'success' : 'danger'} dynamic-alert position-fixed`;
            alertDiv.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
            alertDiv.innerHTML = `
                <i class="fas fa-${type === 'success' ? 'check-circle' : 'exclamation-triangle'}"></i>
                ${message}
                <button type="button" class="btn-close" onclick="this.parentElement.remove()"></button>
            `;

            document.body.appendChild(alertDiv);

            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (alertDiv.parentNode) {
                    alertDiv.remove();
                }
            }, 5000);
        }

        // Utility functions
        function formatNumber(number) {
            // Handle NaN, null, undefined, and infinite values
            if (number === null || number === undefined || isNaN(number) || !isFinite(number)) {
                return '0.00';
            }
            return new Intl.NumberFormat('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(number);
        }

         // Refresh dashboard data
        function updateDashboard() {
            refreshData();
        }
         // Show anomalies function
        function showAnomalies() {
            alert('Anomaly Detection System\n\n' +
                  '‚Ä¢ Unusual market movements\n' +
                  '‚Ä¢ Unexpected position changes\n' +
                  '‚Ä¢ API connection issues\n' +
                  '‚Ä¢ Risk management alerts\n\n' +
                  'Check console logs for detailed anomaly reports.');
        }

        function displayInsights(insights) {
            const container = document.getElementById('insights-content');

            if (!insights || Object.keys(insights).length === 0) {
                container.innerHTML = '<div class="text-muted">No insights available yet.</div>';
                return;
            }

            let html = '';
            for (const [key, value] of Object.entries(insights)) {
                html += `
                    <div class="insight-item">
                        <span class="insight-label">${key}:</span>
                        <span class="insight-value">${value}</span>
                    </div>
                `;
            }
            container.innerHTML = html;
        }

        function displayPredictions(predictions) {
            const container = document.getElementById('predictions-content');

            if (!predictions || predictions.length === 0) {
                container.innerHTML = '<div class="text-muted">No predictions available yet.</div>';
                return;
            }

            let html = '';
            predictions.forEach(function(prediction) {
                const statusClass = prediction.confidence > 0.7 ? 'profitable' : 
                                  prediction.confidence < 0.3 ? 'unprofitable' : 'neutral';

                html += `
                    <div class="prediction-item">
                        <strong>${prediction.symbol}</strong> - ${prediction.direction}
                        <span class="status ${statusClass}">${(prediction.confidence * 100).toFixed(1)}% confidence</span>
                        <small>${prediction.timeframe}</small>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        function showSuccess(containerId, message) {
            const container = document.getElementById(containerId);
            const existingContent = container.innerHTML;
            container.innerHTML = `<div class="success">‚úÖ ${message}</div><br>${existingContent}`;

            // Remove success message after 5 seconds
            setTimeout(() => {
                container.innerHTML = existingContent;
            }, 5000);
        }

        // Safety validation feedback function
        function handleSafetyValidation(data) {
            if (data && data.safety_warnings && data.safety_warnings.length > 0) {
                let warningMessage = '‚ö†Ô∏è Safety corrections were applied:\n\n';
                data.safety_warnings.forEach(function(warning) {
                    warningMessage += '‚Ä¢ ' + warning + '\n';
                });
                warningMessage += '\nConfiguration was saved with safe default values.';

                // Show as a warning alert instead of blocking alert
                showAlert(warningMessage, 'warning');
            }
        }

        // Alert function
        function showAlert(message, type) {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type} alert-dismissible fade show`;
            alertDiv.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            `;

            const container = document.querySelector('.container-fluid'); // Or any specific container you want to insert into
            container.prepend(alertDiv);

            // Automatically close the alert after 5 seconds
            setTimeout(() => {
                alertDiv.remove();
            }, 5000);
        }

        // Include MACD threshold fields in form data collection
        // Include MACD threshold fields in form data collection
        function collectFormData(strategyName) {
            const formData = {};

            formData.symbol = document.getElementById('strategySymbol').value;
            formData.margin = parseFloat(document.getElementById('strategyMargin').value);
            formData.leverage = parseInt(document.getElementById('strategyLeverage').value);
            formData.decimals = parseInt(document.getElementById('strategyDecimals').value);
            formData.timeframe = document.getElementById('strategyTimeframe').value;
            formData.max_loss_pct = parseFloat(document.getElementById('strategyMaxLoss').value);
            formData.assessment_interval = parseInt(document.getElementById('assessmentInterval').value);
            formData.cooldown_period = parseInt(document.getElementById('cooldownPeriod').value);

            // Partial Take Profit Configuration
            formData.partialTpEnabled = document.getElementById('partialTpEnabled').checked;

            if (formData.partialTpEnabled) {
                const threshold = document.getElementById('partialTpPnlThreshold').value;
                const positionSize = document.getElementById('partialTpPositionPercentage').value;

                if (threshold && positionSize) {
                    formData.partial_tp_pnl_threshold = parseFloat(threshold);
                    formData.partial_tp_position_percentage = parseFloat(positionSize);
                }
            }

            if (strategyName.toLowerCase().includes('rsi')) {
                formData.rsi_long_entry = parseInt(document.getElementById('rsiLongEntry').value);
                formData.rsi_long_exit = parseInt(document.getElementById('rsiLongExit').value);
                formData.rsi_short_entry = parseInt(document.getElementById('rsiShortEntry').value);
                formData.rsi_short_exit = parseInt(document.getElementById('rsiShortExit').value);
            }

            if (strategyName.toLowerCase().includes('macd')) {
                formData.macd_fast = parseInt(document.getElementById('macdFast').value);
                formData.macd_slow = parseInt(document.getElementById('macdSlow').value);
                formData.macd_signal = parseInt(document.getElementById('macdSignal').value);
                formData.min_histogram_threshold = parseFloat(document.getElementById('minHistogramThreshold').value);
                formData.macd_entry_threshold = parseFloat(document.getElementById('macdEntryThreshold').value);
                formData.macd_exit_threshold = parseFloat(document.getElementById('macdExitThreshold').value);
                formData.histogram_divergence_lookback = parseInt(document.getElementById('histogramDivergenceLookback').value);
                formData.price_divergence_lookback = parseInt(document.getElementById('priceDivergenceLookback').value);
                formData.confirmation_candles = parseInt(document.getElementById('confirmationCandles').value);
                formData.divergence_strength_min = parseFloat(document.getElementById('divergenceStrengthMin').value);
            }

            return formData;
        }

        // Show safety validation feedback in alert
        function handleSafetyValidation(data) {
            if (data && data.safety_warnings && data.safety_warnings.length > 0) {
                let warningMessage = '‚ö†Ô∏è Safety corrections were applied:\n\n';
                data.safety_warnings.forEach(function(warning) {
                    warningMessage += '‚Ä¢ ' + warning + '\n';
                });
                warningMessage += '\nConfiguration was saved with safe default values.';

                // Show the safety warning as an alert on the page
                showAlert(warningMessage, 'warning');
            }
        }
</script>
</body>
</html>